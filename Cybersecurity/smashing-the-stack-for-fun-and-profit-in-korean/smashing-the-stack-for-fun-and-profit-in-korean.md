[original](./original/stack_smashing.pdf)

.oO Phrack Oo.  
  
7권 49호, 총 16 중 14번째  
  
BugTraq, r00t, 그리고 Underground.Org가 제공함  

# 재미 그리고 이득을 위한 스택 격파하기

## Aleph One
aleph1@underground.org

\`스택 격파\` [C 프로그래밍] n. 많은 C 구현체에서, 루틴 안에 동적 할당된 배열의 끝을 지나쳐 씀으로서 실행 스택을 더럽히는 것이 가능하다. 이러한 코드를 스택 격파라 불리며, 이는 루틴으로부터 리턴하는 것으로 임의의 주소로 점프하는 것을 일으킬 수 있다. 이것은 인류에게 알려진 가장 교활한 데이터 의존적인 버그들을 일으킬 수 있다. 동의어로 스택 폐기, 스택 갈겨 쓰기, 스택 실종이 있다; 스택 어지럽힘([mung](http://www.catb.org/~esr/jargon/html/M/mung.html) the stack)이라는 용어는, 의도적으로 행하여지는 것이 아니기 때문에, 쓰이지 않는다. 스팸을 보라; [`alias`](https://ss64.com/bash/alias.html) 버그, [코어 위의 환당고 춤](http://www.catb.org/jargon/html/F/fandango-on-core.html), 메모리 누수, 앞서기로 인한 누락, [오버런 스크루](http://www.catb.org/jargon/html/O/overrun-screw.html)를 보라.

## *도입*
최근 몇 달간 발견되고 exploited된 버퍼 오버플로우 취약점들이 증가했다. 이들은 syslog, splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt library, at 등이 있다. 이 글은 버퍼 오버플로우가 무엇인지, 그리고 exploits이 어떻게 작동하는지를 설명하려고 시도한다. 어셈블리어에 대한 기초 지식이 필요하다. 가상 메모리 개념의 이해와, gdb를 다뤄본 경험이 매우 도움이 되지만 반드시 필요한 것은 아니다. 또한 Intel x86 CPU, Linux 환경에서 작업한다는 것을 가정한다. 시작하기 전 몇 가지 정의를 내리고자 한다: 버퍼는 동일한 데이터 타입의 다중 인스턴스들을 저장하는 컴퓨터 메모리의 연속적인 블록이다. C 프로그래머는 일반적으로 이를 버퍼 배열과 연관짓는다. 가장 일반적으로는, 문자 배열이다. 배열은, C의 모든 변수들과 마찬가지로, 정적 혹은 동적으로 선언할 수 있다. 정적 변수는 로드타임에 데이터 구역에 할당된다. 동적 배열은 런타임에 스택에 할당된다. 오버플로우하는 것은 위, 가장자리, 경계를 넘치게 채우는 것이다. 우리는 동적 버퍼의 오버플로우에 대해 다룰 것이고, 이는 **스택 기반 버퍼 오버플로우**로 알려져 있다. 

## *프로세스 메모리 편성*
스택 버퍼가 무엇인지 이해하려면 먼저 프로세스가 메모리에 어떻게 편성되는지부터 이해해야 한다. 프로세스는 세 영역으로 나누어진다: 텍스트, 데이터, 그리고 스택. 우리는 스택 구역에 초점을 맞추겠지만, 일단 순서대로 다른 구역들을 간단히 살펴보자. 텍스트 구역은 프로그램에 의해 고정되어있고 코드(명령어들)와 읽기-전용 데이터를 포함한다. 이 구역은 실행 가능한 파일의 텍스트 영역과 상응한다. 이 영역은 일반적으로 읽기-전용으로 표시되며, 여기에 쓰기를 시도하면 세분화 위반(segmentation violation)을 일으킨다. 데이터 영역은 초기화된 데이터와 초기화되지 않은 데이터를 포함한다. 정적 변수가 이 영역에 저장된다. 데이터 영역은 실행 가능한 파일의 데이터-[bss](https://ko.wikipedia.org/wiki/.bss) 영역에 상응한다. 이 영역의 크기는 brk(2) 시스템 호출로 바꿀 수 있다. bss 데이터가 확장하거나 스택이 가용 메모리를 초과한다면, 프로세스는 잠시 멈췄다가 더 큰 메모리 공간으로 다시 작동하도록 재예정된다. 새로운 메모리는 데이터 영역과 스택 영역 사이에 추가된다.

```
/---------------------\  낮은
|                     |  메모리
|        텍스트       |  주소
|                     |
|---------------------|
|      (초기화된)     |
|        데이터       |
|  (초기화되지 않은)  |
|---------------------|
|                     |
|        스택         |  높은
|                     |  메모리
\---------------------/  주소
```
그림 1 프로세스 메모리 영역들  

## *스택이란 무엇인가?*
스택은 컴퓨터 과학에서 자주 쓰이는 추상 데이터 타입이다. 객체들의 스택은 스택에 놓인 마지막 객체가 가장 먼저 제거되는 객체인 속성을 가진다. 이 속성은 흔히 후입선출 큐, 혹은 LIFO라고 불린다. 여러 가지 동작이 스택에 정의되어 있다. 가장 중요한 동작 중 두가지는 `PUSH`와 `POP`이다. `PUSH`는 스택의 꼭대기에 요소를 추가한다. `POP`은, 반대로, 스택의 꼭대기에 있던 마지막 요소를 제거하여 스택 크기를 하나씩 줄인다.

## *왜 스택을 사용하는가?*
현대 컴퓨터는 고-급 언어의 필요성을 염두에 두고 설계되었다. 고-급 언어에 의해 도입된, 프로그램 구조화에서의 가장 중요한 기법은 프로시저 혹은 함수다. 어떻게 보면, 프로시저 호출은 `jump`와 같이 제어의 흐름을 변경하지만, 하지만 `jump`와는 달리, 작업 수행이 끝나면, 함수는 호출 후의 선언문이나 명렁어에 제어를 돌려준다. 이러한 고-급 추상은 스택의 도움으로 구현된다. 스택은 또한 함수에서 지역 변수를 동적으로 할당할 때, 매개변수를 넘겨줄 때, 값을 리턴할 때 쓰이기도 한다.

## *스택 영역*
스택은 데이터를 다믄 메모리의 연속적인 블록이다. 스택 포인터(SP)라고 불리는 레지스터는 스택의 꼭대기를 가리킨다. 스택의 밑바닥은 고정된 주소에 있다. 스택의 크기는 런타임 도중 커널에 의해 동적으로 조정된다. CPU는 스택에 `PUSH` 하고 `POP`하는 명령어를 가지고 있다. 스택은 함수 호출일 때 `PUSH`되고 함수 종료일 때 `POP` 되는 논리적 스택 프레임들로 구성된다. 스택 프레임은 함수의 매개변수, 지역 변수, 그리고 이전 스택 프레임으로 돌아가는데 필요한 데이터(함수 호출 때의 명령어 포인터의 값 포함)를 담고 있다. 구현체에 따라 스택은 낮은 메모리 주소를 향하여 자라거나, 높은 메모리 주소를 향할 수도 있다. 우리는 낮은 메모리를 주소를 향하여 자라는 스택을 사용한다. 이는 Intel, Motorola, SPARC, 그리고 MIPS 프로세서를 사용하는 컴퓨터에서 쓰이는 방식이다. 스택 포인터(`SP`)도 구현체에 따라 달라진다. 스택의 마지막 주소를 가리킬 수도 있고, 또는 스택 다음의 가용 메모리 주소를 가리킬 수도 있다. 여기서는 스택의 마지막 주소를 가리키는 것으로 가정한다. 스택 포인터는 스택의 꼭대기(수치적으로 가장 낮은 주소)를 가리키는데, 프레임 안의 고정 위치를 가리키는 프레임 포인터(`FP`)를 가지는 것이 종종 편하다. 이는 지역 베이스 포인터(`LB`)로도 불린다. 원칙적으로, 지역 변수는 스택 포인터로부터의 오프셋(떨어진 거리)으로 가리킬 수 있다. 하지만, 스택에서 이것저것 들어갔다 빠져나가면서, 오프셋이 바뀐다. 컴파일러가 스택을 추적하여 오프셋을 수정하는 경우가 있지만, 아닌 경우도 있고, 어떠한 경우에도 상당한 관리가 필요하다. 게다가, Intel 기반 프로세서같은 것들은 스택 포인터로부터 떨어진 아는 거리로 변수를 접근하는 것은 여러 개의 명령어를 요구한다. 결과적으로, 스택의 변화로 프레임 포인터와의 거리가 바뀌지 않기 때문에, 지역 변수와 매개변수를 가리키기 위해 많은 컴파일러들은 두번째 레지스터인 프레임 포인터(`FP`)를 사용한다. Intel CPU에서는 해당 목적을 위해 `BP`(`EBP`)가 쓰인다. Motorola CPU에서는 `A7`(스택 포인터)를 제외한 어느 주소 레지스터들이 해당 역할을 한다. 스택이 자라는 방향이 높은 주소에서 낮은 주소로 향하기 때문에, `FP` 기준으로 매개변수는 양수 오프셋을 가지고, 지역 변수는 음수 오프셋을 가진다. 함수가 호출되었을 때 가장 먼저 하는 일은 함수 종료 시 복구하기 위해 이전 `FP`를 저장하는 것이다. 그리고 새로운 `FP`를 만들기 위해 `SP`를 `FP`에 복사하고, 지역 변수가 들어갈 공간을 꾸리도록 `SP`를 증가시킨다. 이는 **함수 프롤로그**라고 불린다. 함수가 종료하자마자, 스택은 다시 깔끔히 정리되어야 하는데, 이를 **함수 에필로그**라고 부른다. Intel의 `ENTER`, `LEAVE` 명령어, 그리고 Motorola의 `LINK`, `UNLINK` 명령어가 함수 프롤로그/에필로그 과정을 효율적으로 해내왔다. 간단한 에제로 스택이 어떻게 생겼는지 살펴보자:
  
**[`example1.c`](./files/example1.c)**
```c
void function(int a, int b, int c) {
    char buffer1[5];
    char buffer2[10];
}

void main() {
    function(1, 2, 3);
}
```

프로그램이 `function()`을 호출하기 위해 무얼 하는지 이해하기 위해 어셈블리 코드를 생성하는 `-S` 옵션을 주어 gcc로 컴파일했다. 

```
$ gcc -S -o example1.s example1.c
```

어셈블리어 결과물을 보아하니 `function()` 호출은 다음과 같이 번역되었다:
```assembly
pushl $3
pushl $2
pushl $1
call function
```

이는 함수의 인자 3개를 스택에 거꾸로 `push`하고, 그리고 `function()`을 호출한다. 명령어 `call`은 스택에 명령어 포인터(`IP`)를 `push`한다. 우리는 저장된 `IP`를 리턴 어드레스(`RET`)라고 부른다. 함수에서 가장 먼저 처리되는 것은 함수 프롤로그이다:

```assembly
pushl %ebp
movl $esp, $ebp
subl $20, $esp
```

이는 프레임 포인터인 `EBP`를 스택에 `push`한다. 그리고 현재 `SP`를 `EBP`에 복사하여, 이를 새로운 `FP`로 만든다. 저장된 `FP`를 `SFP`라고 부른다. 이후 `SP`에서 필요한 공간만큼을 빼서 지역 변수를 위한 공간을 할당한다.  
  
반드시 메모리는 여러 개의 워드 크기로 주소가 짜인다는 것을 알아야 한다. 여기서 워드는 `4 bytes` 또는 `32 bits`이다. 따라서 `5 byte` 버퍼는 실제로 메모리의 `8 bytes`(`2 words`)를 차지하고, `10 byte` 버퍼는 실제로 메모리의 `12 bytes`(`3 words`)를 차지한다. 이것은 `SP`에서 `20`을 뺀 이유이다. 이를 고려하면 `function()`이 호출될 때 스택은 다음과 같다(각 `+`는 하나의 바이트를 나타낸다):

```
bottom of                                                                               top of
memory                                                                                  memory
          buffer2            buffer1       sfp      ret      a        b        c
<------  [ ++++ ++++ ++++ ] [ ++++ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ]

top of                                                                              bottom of
stack                                                                                   stack
```
