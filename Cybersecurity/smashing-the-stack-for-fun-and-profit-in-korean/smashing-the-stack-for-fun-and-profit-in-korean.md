[original](./original/stack_smashing.pdf)

.oO Phrack Oo.  
  
7권 49호, 총 16 중 14번째  
  
BugTraq, r00t, 그리고 Underground.Org가 제공함  

# 재미 그리고 이득을 위한 스택 격파하기

## Aleph One
aleph1@underground.org

\`스택 격파\` [C 프로그래밍] n. 많은 C 구현체에서, 루틴 안에 동적 할당된 배열의 끝을 지나쳐 씀으로서 실행 스택을 더럽히는 것이 가능하다. 이러한 코드를 스택 격파라 불리며, 이는 루틴으로부터 리턴하는 것으로 임의의 주소로 점프하는 것을 일으킬 수 있다. 이것은 인류에게 알려진 가장 교활한 데이터 의존적인 버그들을 일으킬 수 있다. 동의어로 스택 폐기, 스택 갈겨 쓰기, 스택 실종이 있다; 스택 어지럽힘([mung](http://www.catb.org/~esr/jargon/html/M/mung.html) the stack)이라는 용어는, 의도적으로 행하여지는 것이 아니기 때문에, 쓰이지 않는다. 스팸을 보라; [`alias`](https://ss64.com/bash/alias.html) 버그, [코어 위의 환당고 춤](http://www.catb.org/jargon/html/F/fandango-on-core.html), 메모리 누수, 앞서기로 인한 누락, [오버런 스크루](http://www.catb.org/jargon/html/O/overrun-screw.html)를 보라.

## *도입*
최근 몇 달간 발견되고 exploited된 버퍼 오버플로우 취약점들이 증가했다. 이들은 syslog, splitvt, sendmail 8.7.5, Linux/FreeBSD mount, Xt library, at 등이 있다. 이 글은 버퍼 오버플로우가 무엇인지, 그리고 exploits이 어떻게 작동하는지를 설명하려고 시도한다. 어셈블리어에 대한 기초 지식이 필요하다. 가상 메모리 개념의 이해와, gdb를 다뤄본 경험이 매우 도움이 되지만 반드시 필요한 것은 아니다. 또한 Intel x86 CPU, Linux 환경에서 작업한다는 것을 가정한다. 시작하기 전 몇 가지 정의를 내리고자 한다: 버퍼는 동일한 데이터 타입의 다중 인스턴스들을 저장하는 컴퓨터 메모리의 연속적인 블록이다. C 프로그래머는 일반적으로 이를 버퍼 배열과 연관짓는다. 가장 일반적으로는, 문자 배열이다. 배열은, C의 모든 변수들과 마찬가지로, 정적 혹은 동적으로 선언할 수 있다. 정적 변수는 로드타임에 데이터 구역에 할당된다. 동적 배열은 런타임에 스택에 할당된다. 오버플로우하는 것은 위, 가장자리, 경계를 넘치게 채우는 것이다. 우리는 동적 버퍼의 오버플로우에 대해 다룰 것이고, 이는 **스택 기반 버퍼 오버플로우**로 알려져 있다. 

## *프로세스 메모리 편성*
스택 버퍼가 무엇인지 이해하려면 먼저 프로세스가 메모리에 어떻게 편성되는지부터 이해해야 한다. 프로세스는 세 영역으로 나누어진다: 텍스트, 데이터, 그리고 스택. 우리는 스택 구역에 초점을 맞추겠지만, 일단 순서대로 다른 구역들을 간단히 살펴보자. 텍스트 구역은 프로그램에 의해 고정되어있고 코드(명령어들)와 읽기-전용 데이터를 포함한다. 이 구역은 실행 가능한 파일의 텍스트 영역과 상응한다. 이 영역은 일반적으로 읽기-전용으로 표시되며, 여기에 쓰기를 시도하면 세분화 위반(segmentation violation)을 일으킨다. 데이터 영역은 초기화된 데이터와 초기화되지 않은 데이터를 포함한다. 정적 변수가 이 영역에 저장된다. 데이터 영역은 실행 가능한 파일의 데이터-[bss](https://ko.wikipedia.org/wiki/.bss) 영역에 상응한다. 이 영역의 크기는 brk(2) 시스템 호출로 바꿀 수 있다. bss 데이터가 확장하거나 스택이 가용 메모리를 초과한다면, 프로세스는 잠시 멈췄다가 더 큰 메모리 공간으로 다시 작동하도록 재예정된다. 새로운 메모리는 데이터 영역과 스택 영역 사이에 추가된다.

```
/---------------------\  낮은
|                     |  메모리
|        텍스트       |  주소
|                     |
|---------------------|
|      (초기화된)     |
|        데이터       |
|  (초기화되지 않은)  |
|---------------------|
|                     |
|        스택         |  높은
|                     |  메모리
\---------------------/  주소
```
그림 1 프로세스 메모리 영역들  

## *스택이란 무엇인가?*
스택은 컴퓨터 과학에서 자주 쓰이는 추상 데이터 타입이다. 객체들의 스택은 스택에 놓인 마지막 객체가 가장 먼저 제거되는 객체인 속성을 가진다. 이 속성은 흔히 후입선출 큐, 혹은 LIFO라고 불린다. 여러 가지 동작이 스택에 정의되어 있다. 가장 중요한 동작 중 두가지는 `PUSH`와 `POP`이다. `PUSH`는 스택의 꼭대기에 요소를 추가한다. `POP`은, 반대로, 스택의 꼭대기에 있던 마지막 요소를 제거하여 스택 크기를 하나씩 줄인다.

## *왜 스택을 사용하는가?*
현대 컴퓨터는 고-급 언어의 필요성을 염두에 두고 설계되었다. 고-급 언어에 의해 도입된, 프로그램 구조화에서의 가장 중요한 기법은 프로시저 혹은 함수다. 어떻게 보면, 프로시저 호출은 `jump`와 같이 제어의 흐름을 변경하지만, 하지만 `jump`와는 달리, 작업 수행이 끝나면, 함수는 호출 후의 선언문이나 명렁어에 제어를 돌려준다. 이러한 고-급 추상은 스택의 도움으로 구현된다. 스택은 또한 함수에서 지역 변수를 동적으로 할당할 때, 매개변수를 넘겨줄 때, 값을 리턴할 때 쓰이기도 한다.

## *스택 영역*
스택은 데이터를 다믄 메모리의 연속적인 블록이다. 스택 포인터(SP)라고 불리는 레지스터는 스택의 꼭대기를 가리킨다. 스택의 밑바닥은 고정된 주소에 있다. 스택의 크기는 런타임 도중 커널에 의해 동적으로 조정된다. CPU는 스택에 `PUSH` 하고 `POP`하는 명령어를 가지고 있다. 스택은 함수 호출일 때 `PUSH`되고 함수 종료일 때 `POP` 되는 논리적 스택 프레임들로 구성된다. 스택 프레임은 함수의 매개변수, 지역 변수, 그리고 이전 스택 프레임으로 돌아가는데 필요한 데이터(함수 호출 때의 명령어 포인터의 값 포함)를 담고 있다. 구현체에 따라 스택은 낮은 메모리 주소를 향하여 자라거나, 높은 메모리 주소를 향할 수도 있다. 우리는 낮은 메모리를 주소를 향하여 자라는 스택을 사용한다. 이는 Intel, Motorola, SPARC, 그리고 MIPS 프로세서를 사용하는 컴퓨터에서 쓰이는 방식이다. 스택 포인터(`SP`)도 구현체에 따라 달라진다. 스택의 마지막 주소를 가리킬 수도 있고, 또는 스택 다음의 가용 메모리 주소를 가리킬 수도 있다. 여기서는 스택의 마지막 주소를 가리키는 것으로 가정한다. 스택 포인터는 스택의 꼭대기(수치적으로 가장 낮은 주소)를 가리키는데, 프레임 안의 고정 위치를 가리키는 프레임 포인터(`FP`)를 가지는 것이 종종 편하다. 이는 지역 베이스 포인터(`LB`)로도 불린다. 원칙적으로, 지역 변수는 스택 포인터로부터의 오프셋(떨어진 거리)으로 가리킬 수 있다. 하지만, 스택에서 이것저것 들어갔다 빠져나가면서, 오프셋이 바뀐다. 컴파일러가 스택을 추적하여 오프셋을 수정하는 경우가 있지만, 아닌 경우도 있고, 어떠한 경우에도 상당한 관리가 필요하다. 게다가, Intel 기반 프로세서같은 것들은 스택 포인터로부터 떨어진 아는 거리로 변수를 접근하는 것은 여러 개의 명령어를 요구한다. 결과적으로, 스택의 변화로 프레임 포인터와의 거리가 바뀌지 않기 때문에, 지역 변수와 매개변수를 가리키기 위해 많은 컴파일러들은 두번째 레지스터인 프레임 포인터(`FP`)를 사용한다. Intel CPU에서는 해당 목적을 위해 `BP`(`EBP`)가 쓰인다. Motorola CPU에서는 `A7`(스택 포인터)를 제외한 어느 주소 레지스터들이 해당 역할을 한다. 스택이 자라는 방향이 높은 주소에서 낮은 주소로 향하기 때문에, `FP` 기준으로 매개변수는 양수 오프셋을 가지고, 지역 변수는 음수 오프셋을 가진다. 함수가 호출되었을 때 가장 먼저 하는 일은 함수 종료 시 복구하기 위해 이전 `FP`를 저장하는 것이다. 그리고 새로운 `FP`를 만들기 위해 `SP`를 `FP`에 복사하고, 지역 변수가 들어갈 공간을 꾸리도록 `SP`를 증가시킨다. 이는 **함수 프롤로그**라고 불린다. 함수가 종료하자마자, 스택은 다시 깔끔히 정리되어야 하는데, 이를 **함수 에필로그**라고 부른다. Intel의 `ENTER`, `LEAVE` 명령어, 그리고 Motorola의 `LINK`, `UNLINK` 명령어가 함수 프롤로그/에필로그 과정을 효율적으로 해내왔다. 간단한 에제로 스택이 어떻게 생겼는지 살펴보자:
  
**[`example1.c`](./files/example1.c)**
```c
void function(int a, int b, int c) {
    char buffer1[5];
    char buffer2[10];
}

void main() {
    function(1, 2, 3);
}
```

프로그램이 `function()`을 호출하기 위해 무얼 하는지 이해하기 위해 어셈블리 코드를 생성하는 `-S` 옵션을 주어 gcc로 컴파일했다. 

```
$ gcc -S -o example1.s example1.c
```

어셈블리어 결과물을 보아하니 `function()` 호출은 다음과 같이 번역되었다:
```assembly
pushl $3
pushl $2
pushl $1
call function
```

이는 함수의 인자 3개를 스택에 거꾸로 `push`하고, 그리고 `function()`을 호출한다. 명령어 `call`은 스택에 명령어 포인터(`IP`)를 `push`한다. 우리는 저장된 `IP`를 리턴 어드레스(`RET`)라고 부른다. 함수에서 가장 먼저 처리되는 것은 함수 프롤로그이다:

```assembly
pushl %ebp
movl $esp, $ebp
subl $20, $esp
```

이는 프레임 포인터인 `EBP`를 스택에 `push`한다. 그리고 현재 `SP`를 `EBP`에 복사하여, 이를 새로운 `FP`로 만든다. 저장된 `FP`를 `SFP`라고 부른다. 이후 `SP`에서 필요한 공간만큼을 빼서 지역 변수를 위한 공간을 할당한다.  
  
반드시 메모리는 여러 개의 워드 크기로 주소가 짜인다는 것을 알아야 한다. 여기서 워드는 `4 bytes` 또는 `32 bits`이다. 따라서 `5 byte` 버퍼는 실제로 메모리의 `8 bytes`(`2 words`)를 차지하고, `10 byte` 버퍼는 실제로 메모리의 `12 bytes`(`3 words`)를 차지한다. 이것은 `SP`에서 `20`을 뺀 이유이다. 이를 고려하면 `function()`이 호출될 때 스택은 다음과 같다(각 `+`는 하나의 바이트를 나타낸다):

```
bottom of                                                                               top of
memory                                                                                  memory
          buffer2            buffer1       sfp      ret      a        b        c
<------  [ ++++ ++++ ++++ ] [ ++++ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ]

top of                                                                              bottom of
stack                                                                                   stack
```

## *버퍼 오버플로우*
버퍼 오버플로우는 버퍼에 한게보다 더 많은 데이터를 담은 결과이다. 이렇게 종종 발견되는 프로그래밍 오류를 임의 코드를 실행하는 데 이용할 수 있을까? 또다른 예제를 보자:
  
**[`example2.c`](./files/example2.c)**
```c
void function(char *str){
	char bufer[16];
	
	strcpy(buffer, str);
}

void main() {
	char large_string[256];
	int i;
	
	for( i = 0; i < 255; i++)
		large_string[i] = 'A';
	
	function(large_string);
}
```

이 프로그램은 전형적인 버퍼 오버플로우 코딩 오류가 있는 함수를 가진다. 이 함수는 `strncpy()` 대신 `strcpy()`를 사용하여 매개변수로 받은 문자열을 경계 검사 없이 복사한다. 이 프로그램을 실행한다면 세분화 위반(segmentation violation)을 일으킬 것이다. 함수 호출 시 스택의 모습을 살펴보자:

```
bottom of                                                   top of
memory                                                      memory
          buffer                  sfp      ret      *str      
<------  [ ++++ ++++ ++++ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ]

top of                                                      bottom of
stack                                                       stack
```

무슨 일이 벌어지는 것일까? 왜 세분화 위반(segmentation violation)이 일어날까? 간단하다. `strcpy()`는 `*str`(`larger_string[]`)의 내용을 `buffer[]`로 null 문자를 만날 때까지 복사한다. `buffer[]`가 `*str`보다 매우 작은 것을 알 수 있다. `buffer[]`는 `16 bytes` 길이이고, 이를 `256 bytes`로 채우려고 했다. 이는 스택 안 버퍼 뒤의 `240 bytes`가 덮어씌워졌다는 것을 뜻한다. 여기에 `SFP`, `RET`, 심지어 `*str`까지 포함된다. `large_string`에 `A` 문자를 채웠다. 이는 hex 값으로 `0x41`이다. 이는 리턴 주소가 `0x41414141`이 되었다는 것이다. 이는 프로세스 주소 공간을 벗어난다. 이것이 함수가 종료하고 그 주소에서 다음 명령어를 읽으려고 할 때 세분화 위반(segmentation violation)을 일으키는 이유이다. 그래서 버퍼 오버플로우는 함수의 리턴 주소를 바꿀 수 있게 한다. 이렇게 프로그램의 실행의 흐름을 바꿀 수 있다. 첫번째 예제로 돌아가서 스택의 모습을 다시 한번 떠올려보자:

```
bottom of                                                                               top of
memory                                                                                  memory
          buffer2            buffer1       sfp      ret      a        b        c
<------  [ ++++ ++++ ++++ ] [ ++++ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ] [ ++++ ]

top of                                                                              bottom of
stack                                                                                   stack
```

첫번째 예제를 수정하여 리턴 주소를 덮어쓰고, 어떻게 임의 코드를 실행할 수 있는지 증명해보자. 스택의 `buffer1[]` 이전이 `SFP`이고, 그 이전은 리턴 주소이다. 이는 `buffer1[]`에서 `4 bytes`만큼 떨어져 있다.  하지만 `buffer1[]`이 실제로는 `2 word`, 즉 `8 bytes`만큼의 길이라는 것을 기억해야 한다. 따라서 리턴 주소는 `buffer1[]`의 시작 주소로부터 `12 bytes`만큼 떨어져 있다. 리턴값을 수정하여 함수 호출 후 할당문 `x = 1;`를 건너뛰도록 해볼 것이다. 이를 위해 리턴 주소로 `10 bytes`를 더한다.  
  
**[`example3.c`](./files/example3.c)**
```c
void function(int a, int b, int c) {
    char buffer1[5];
    char buffer2[10];
    int *ret;

    ret = buffer1 + 12; // ret는 buffer1[]으로부터 12 bytes 만큼 떨어져 있다.
    (*ret) += 10;
}

void main() {
    int x;

    x = 0;
    function(1, 2, 3);
    x = 1;
    printf("%d\n", x);
}
```

코드에 추가한 것은 `buffer1[]`의 주소에 `12`를 더한 것이다. 이 새로운 주소는 리턴 주소가 저장된 곳이다. 우리는 할당문을 건너뛰고 `printf` 호출로 가고 싶다. 리턴 주소에 `10`을 더하는 것은 어떻게 알아낸 것인가? 컴파일 후 gdb로 살펴보았다:

```
[aleph1]$ gdb example3
GDB ...
...
...
(no debugging symbols found)...
(gdb) disassemble main
Dump of assembler code for function main:
0x8000490 :     pushl    %ebp
0x8000491 :     movl     %esp, %ebp
0x8000493 :     subl     $0x4, %esp
0x8000496 :     movl     $0x0, 0xfffffffc(%ebp)
0x800049d :     pushl    $0x3
0x800049f :     pushl    $0x2
0x80004a1 :     pushl    $0x1
0x80004a3 :     call     0x8000470
0x80004a8 :     addl     $0xc, %esp              # the value that the RET will be.
0x80004ab :     movl     $0x1, 0xfffffffc(%ebp)  # the assignment we want to jump past. 
0x80004b2 :     movl     0xfffffffc(%ebp), %eax  # the next instruction we want to execute.
0x80004b5 :     pushl    %eax
0x80004b6 :     pushl    $0x80004f8
0x80004bb :     call     0x8000378
0x80004c0 :     addl     $0x8, %esp
0x80004c3 :     movl     %ebp, %esp
0x80004c5 :     popl     %ebp
0x80004c6 :     ret
0x80004c7 :     nop
```

`function()` 호출 시 `RET`이 `0x80004a8`이 되는 것을 알 수 있고, 할당문 `0x80004ab`를 건너뛰고 싶다. 우리가 실행하고 싶은 다음 명령어는 `0x80004b2`에 있다. `0x80004b2 - 0x80004a8 = 10 bytes`의 거리임을 알 수 있다.